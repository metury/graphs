# Problém **MinCut** *(minimální řez)* pomocí pravděpodobnostního algoritmu

Algoritmus jen v každé iteraci náhodně kontrahuje jednu hranu, dokud nemá právě jen 2 vrcholy, potom počet hran je roven velikosti řezu.

V našem případě si ukážeme jen jednu iteraci. Normální se algoritmus vícekrát opakuje pro větší pravděpodobnost správného výsledku.

## Graf na vstupu:

```mermaid
graph TD;
0(" ");
1(" ");
2(" ");
3(" ");
4(" ");
5(" ");
6(" ");
7(" ");
8(" ");
9(" ");
	0 --- 1;
	1 --- 2;
	2 --- 3;
	3 --- 4;
	4 --- 0;
	0 --- 5;
	1 --- 6;
	2 --- 7;
	3 --- 8;
	4 --- 9;
	5 --- 7;
	5 --- 8;
	6 --- 8;
	6 --- 9;
	7 --- 9;
```

Nyní už budeme postupně iterovat. S tím, že v každém momentu očíslujeme vrcholy a hrany pro přehlednost, a taky se zbavíme smyček.

## Krok 1

V tomhle kroku kontrahujeme hranu `[1;NaN;6]`.

```mermaid
graph TD;
0("0.0");
1("1.0");
2("2.0");
3("3.0");
4("4.0");
5("5.0");
6("6.0");
7("7.0");
8("8.0");
9("9.0");
	0 -- "0.0" --- 1;
	1 -- "1.0" --- 2;
	2 -- "2.0" --- 3;
	3 -- "3.0" --- 4;
	4 -- "4.0" --- 0;
	0 -- "5.0" --- 5;
	1 -. "6.0" -.- 6;
	2 -- "7.0" --- 7;
	3 -- "8.0" --- 8;
	4 -- "9.0" --- 9;
	5 -- "10.0" --- 7;
	5 -- "11.0" --- 8;
	6 -- "12.0" --- 8;
	6 -- "13.0" --- 9;
	7 -- "14.0" --- 9;
```

A získáváme:

```mermaid
graph TD;
0("0.0");
1("2.0");
2("3.0");
3("4.0");
4("5.0");
5("7.0");
6("8.0");
7("9.0");
8(" ");
	0 -- "0.0" --- 8;
	8 -- "1.0" --- 1;
	1 -- "2.0" --- 2;
	2 -- "3.0" --- 3;
	3 -- "4.0" --- 0;
	0 -- "5.0" --- 4;
	1 -- "7.0" --- 5;
	2 -- "8.0" --- 6;
	3 -- "9.0" --- 7;
	4 -- "10.0" --- 5;
	4 -- "11.0" --- 6;
	8 -- "12.0" --- 6;
	8 -- "13.0" --- 7;
	5 -- "14.0" --- 7;
```

## Krok 2

V tomhle kroku kontrahujeme hranu `[1;NaN;6]`.

```mermaid
graph TD;
0("0.0");
1("1.0");
2("2.0");
3("3.0");
4("4.0");
5("5.0");
6("6.0");
7("7.0");
8("8.0");
	0 -- "0.0" --- 8;
	8 -- "1.0" --- 1;
	1 -- "2.0" --- 2;
	2 -- "3.0" --- 3;
	3 -- "4.0" --- 0;
	0 -- "5.0" --- 4;
	1 -. "6.0" -.- 5;
	2 -- "7.0" --- 6;
	3 -- "8.0" --- 7;
	4 -- "9.0" --- 5;
	4 -- "10.0" --- 6;
	8 -- "11.0" --- 6;
	8 -- "12.0" --- 7;
	5 -- "13.0" --- 7;
```

A získáváme:

```mermaid
graph TD;
0("0.0");
1("2.0");
2("3.0");
3("4.0");
4("6.0");
5("7.0");
6("8.0");
7(" ");
	0 -- "0.0" --- 6;
	6 -- "1.0" --- 7;
	7 -- "2.0" --- 1;
	1 -- "3.0" --- 2;
	2 -- "4.0" --- 0;
	0 -- "5.0" --- 3;
	1 -- "7.0" --- 4;
	2 -- "8.0" --- 5;
	3 -- "9.0" --- 7;
	3 -- "10.0" --- 4;
	6 -- "11.0" --- 4;
	6 -- "12.0" --- 5;
	7 -- "13.0" --- 5;
```

## Krok 3

V tomhle kroku kontrahujeme hranu `[3;NaN;8]`.

```mermaid
graph TD;
0("0.0");
1("1.0");
2("2.0");
3("3.0");
4("4.0");
5("5.0");
6("6.0");
7("7.0");
	0 -- "0.0" --- 6;
	6 -- "1.0" --- 7;
	7 -- "2.0" --- 1;
	1 -- "3.0" --- 2;
	2 -- "4.0" --- 0;
	0 -- "5.0" --- 3;
	1 -- "6.0" --- 4;
	2 -- "7.0" --- 5;
	3 -. "8.0" -.- 7;
	3 -- "9.0" --- 4;
	6 -- "10.0" --- 4;
	6 -- "11.0" --- 5;
	7 -- "12.0" --- 5;
```

A získáváme:

```mermaid
graph TD;
0("0.0");
1("1.0");
2("2.0");
3("4.0");
4("5.0");
5("6.0");
6(" ");
	0 -- "0.0" --- 5;
	5 -- "1.0" --- 6;
	6 -- "2.0" --- 1;
	1 -- "3.0" --- 2;
	2 -- "4.0" --- 0;
	0 -- "5.0" --- 6;
	1 -- "6.0" --- 3;
	2 -- "7.0" --- 4;
	6 -- "9.0" --- 3;
	5 -- "10.0" --- 3;
	5 -- "11.0" --- 4;
	6 -- "12.0" --- 4;
```

## Krok 4

V tomhle kroku kontrahujeme hranu `[2;NaN;7]`.

```mermaid
graph TD;
0("0.0");
1("1.0");
2("2.0");
3("3.0");
4("4.0");
5("5.0");
6("6.0");
	0 -- "0.0" --- 5;
	5 -- "1.0" --- 6;
	6 -- "2.0" --- 1;
	1 -- "3.0" --- 2;
	2 -- "4.0" --- 0;
	0 -- "5.0" --- 6;
	1 -- "6.0" --- 3;
	2 -. "7.0" -.- 4;
	6 -- "8.0" --- 3;
	5 -- "9.0" --- 3;
	5 -- "10.0" --- 4;
	6 -- "11.0" --- 4;
```

A získáváme:

```mermaid
graph TD;
0("0.0");
1("1.0");
2("3.0");
3("5.0");
4("6.0");
5(" ");
	0 -- "0.0" --- 3;
	3 -- "1.0" --- 4;
	4 -- "2.0" --- 1;
	1 -- "3.0" --- 5;
	5 -- "4.0" --- 0;
	0 -- "5.0" --- 4;
	1 -- "6.0" --- 2;
	4 -- "8.0" --- 2;
	3 -- "9.0" --- 2;
	3 -- "10.0" --- 5;
	4 -- "11.0" --- 5;
```

## Krok 5

V tomhle kroku kontrahujeme hranu `[4;NaN;9]`.

```mermaid
graph TD;
0("0.0");
1("1.0");
2("2.0");
3("3.0");
4("4.0");
5("5.0");
	0 -- "0.0" --- 3;
	3 -- "1.0" --- 4;
	4 -- "2.0" --- 1;
	1 -- "3.0" --- 5;
	5 -- "4.0" --- 0;
	0 -- "5.0" --- 4;
	1 -- "6.0" --- 2;
	4 -- "7.0" --- 2;
	3 -- "8.0" --- 2;
	3 -. "9.0" -.- 5;
	4 -- "10.0" --- 5;
```

A získáváme:

```mermaid
graph TD;
0("0.0");
1("1.0");
2("2.0");
3("4.0");
4(" ");
	0 -- "0.0" --- 4;
	4 -- "1.0" --- 3;
	3 -- "2.0" --- 1;
	1 -- "3.0" --- 4;
	4 -- "4.0" --- 0;
	0 -- "5.0" --- 3;
	1 -- "6.0" --- 2;
	3 -- "7.0" --- 2;
	4 -- "8.0" --- 2;
	3 -- "10.0" --- 4;
```

## Krok 6

V tomhle kroku kontrahujeme hranu `[0;NaN;1]`.

```mermaid
graph TD;
0("0.0");
1("1.0");
2("2.0");
3("3.0");
4("4.0");
	0 -. "0.0" -.- 4;
	4 -- "1.0" --- 3;
	3 -- "2.0" --- 1;
	1 -- "3.0" --- 4;
	4 -- "4.0" --- 0;
	0 -- "5.0" --- 3;
	1 -- "6.0" --- 2;
	3 -- "7.0" --- 2;
	4 -- "8.0" --- 2;
	3 -- "9.0" --- 4;
```

A získáváme:

```mermaid
graph TD;
0("1.0");
1("2.0");
2("3.0");
3(" ");
	3 -- "1.0" --- 2;
	2 -- "2.0" --- 0;
	0 -- "3.0" --- 3;
	3 -- "4.0" --- 3;
	3 -- "5.0" --- 2;
	0 -- "6.0" --- 1;
	2 -- "7.0" --- 1;
	3 -- "8.0" --- 1;
	2 -- "9.0" --- 3;
```

## Krok 7

V tomhle kroku kontrahujeme hranu `[2;NaN;3]`.

```mermaid
graph TD;
0("0.0");
1("1.0");
2("2.0");
3("3.0");
	3 -- "0.0" --- 2;
	2 -- "1.0" --- 0;
	0 -. "2.0" -.- 3;
	3 -- "4.0" --- 2;
	0 -- "5.0" --- 1;
	2 -- "6.0" --- 1;
	3 -- "7.0" --- 1;
	2 -- "8.0" --- 3;
```

A získáváme:

```mermaid
graph TD;
0("1.0");
1("2.0");
2(" ");
	2 -- "0.0" --- 1;
	1 -- "1.0" --- 2;
	2 -- "4.0" --- 1;
	2 -- "5.0" --- 0;
	1 -- "6.0" --- 0;
	2 -- "7.0" --- 0;
	1 -- "8.0" --- 2;
```

## Krok 8

V tomhle kroku kontrahujeme hranu `[0;NaN;1]`.

```mermaid
graph TD;
0("0.0");
1("1.0");
2("2.0");
	2 -. "0.0" -.- 1;
	1 -- "1.0" --- 2;
	2 -- "2.0" --- 1;
	2 -- "3.0" --- 0;
	1 -- "4.0" --- 0;
	2 -- "5.0" --- 0;
	1 -- "6.0" --- 2;
```

A získáváme:

```mermaid
graph TD;
0("0.0");
1(" ");
	1 -- "1.0" --- 1;
	1 -- "2.0" --- 1;
	1 -- "3.0" --- 0;
	1 -- "4.0" --- 0;
	1 -- "5.0" --- 0;
	1 -- "6.0" --- 1;
```

Tímto konkrétním postupem jsem došli k výsledku, že minimální řez má velikost nejvýše: **3**

*Pokud bychom tento algoritmus zopakovali aspoň tolikrát, kolik je vrcholů, tak získáme výsledek: **3***

## Další postupy:

Protože graf je celkem velký, tak není doporučený použít hledání hrubou sílou, ale za to můžeme na druhou stranu použít celkem dost efektivní algoritmus Karger-Steinův, který používá předem ukázanou kontrakci hrany. Přesně je to rekurzivní používání daného postupu na nižším počtu vrcholů, dokud se nedostane na nějakou hodnotu, po které se už použije hrubá síla. Konkrétní výsledek potom je: **3**
